<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>Obsidian Vault</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 21 Aug 2024 16:58:23 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 21 Aug 2024 16:58:23 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Semana 1 (Semestre 2)]]></title><description><![CDATA[ 
 <br>En esta semana me dediqué a lograr corrar magcolloids en mi computadora, una vez hecho y hacer las simulaciones del Walkthrough, me dediqué a hacer el primer paso, lograr hacer una cadena de particulas, lo cual lo logré creando una nueva función appoyado de otra funcion:<br>def initial_straight_line_setup(n_of_particles, packing = 0.05, height = 4, radius=1.4):

&nbsp; &nbsp; """

&nbsp; &nbsp; This function returns an array of initial positions of particles in a straight line, and

&nbsp; &nbsp; a region where these particles are enclosed with a packing fraction "packing"

&nbsp; &nbsp; The particles are initially set in a square array, as far from each other as possible.

&nbsp; &nbsp; """

  

&nbsp; &nbsp; part_in_edge = int(np.round(n_of_particles))

&nbsp; &nbsp; n_of_particles = part_in_edge

&nbsp; &nbsp; print("n_of_particles", n_of_particles)

  

&nbsp; &nbsp; area_particle = n_of_particles*radius**2*np.pi

&nbsp; &nbsp; print("area particle", area_particle)

&nbsp; &nbsp; area_region = area_particle/packing

&nbsp; &nbsp; print("area region", area_region)

  

&nbsp; &nbsp; length_region = np.sqrt(area_region)

&nbsp; &nbsp; print("length region", length_region)

&nbsp; &nbsp; part_separation = length_region/part_in_edge

&nbsp; &nbsp; print("part separation", part_separation)

  

&nbsp; &nbsp; x_loc = np.linspace(

&nbsp; &nbsp; &nbsp; &nbsp; -length_region/2+part_separation/2,

&nbsp; &nbsp; &nbsp; &nbsp; length_region/2-part_separation/2,part_in_edge)

&nbsp; &nbsp; y_loc = 0

&nbsp; &nbsp; [X,Y] = np.meshgrid(x_loc,y_loc)

&nbsp; &nbsp; Z = np.zeros(np.shape(X))

  

&nbsp; &nbsp; initial_positions = np.array([[x,y,z] for (x,y,z) in zip(X.flatten(),Y.flatten(),Z.flatten())])

&nbsp; &nbsp; if part_separation&lt;2*radius:

&nbsp; &nbsp; &nbsp; &nbsp; raise ValueError("packing is too high")

  

&nbsp; &nbsp; region = [np.round(length_region),np.round(length_region), height]

&nbsp; &nbsp; return region, initial_positions
Copy<br>Esta función logra crear una cadena de partículas dependiendo del input que le demos. El packing tuvo que ser cambiado de 0.3 a 0.05 ya que se obtenía un error. <br>Después de esto, se aplicó la función field, la cual tengo entendido es la que simula el campo magnético externo. Desde una posición inicial de cadena, estos son alguno ]]></description><link>Reporte Semanal\Semestre 2\Semana 1 (Semestre 2).html</link><guid isPermaLink="false">Reporte Semanal/Semestre 2/Semana 1 (Semestre 2).md</guid><pubDate>Mon, 12 Aug 2024 20:33:53 GMT</pubDate></item><item><title><![CDATA[Semana 2 (Semestre 2)]]></title><description><![CDATA[ 
 <br>Esta semana, estuve tratando de adaptar el codigo, de LAMMPS, donde trato de crear bonds con angles.<br>
Tuve bastantes problemas tratando de meter el Angle.<br>
Uno de los problemas que solucioné y que no sabía que pasaba, era que en el read data, dependiendo del atom style, debe llebar parámetros específicos para funcionar.<br>
Este es el código hasta el momento, a falta de revisión. <br># 3D LJ simulation of a binary mixture with Langevin thermostat

dimension       3
boundary        p p p
atom_style      hybrid sphere paramagnet angle
bond_style	fene
angle_style 	harmonic
#dihedral_style	harmonic

units micro

read_data 	polymer.data

neighbor        2.0 bin
neigh_modify    delay 5

group Atoms type 1

pair_style	lj/cut 1.128
pair_coeff	* * 1.0 1.0 1.128

## magnetic field
variable Bmag atom 2.6614538978577816e-06
variable freq atom 0.0
variable theta atom 1.5707963267948966
variable phi atom 0.0

variable fieldx atom v_Bmag*cos(v_freq*time*2*PI+v_phi)*sin(v_theta)
variable fieldy atom v_Bmag*sin(v_freq*time*2*PI+v_phi)*sin(v_theta)
variable fieldz atom v_Bmag*cos(v_theta)

fix 1 Atoms setdipole v_fieldx v_fieldy v_fieldz 1
fix 2 Atoms bd 1 0.001 56670

fix 3 Atoms addforce 0 0.0 -0.0
#fix 6 Atoms wall/lj126 zlo EDGE 0.01 1.247258205396475  1.4 zhi EDGE 0.01 1.247258205396475  1.4

compute erot all erotate/sphere
thermo_style custom step temp epair c_erot etotal press
dump 1 all custom 33 /home/hapless/Projects/LammpsScripts/OldHomework/dump.polymer id type x y z
#thermo_style custom step atoms

#minimize 1e-25 1e-25 500000 1000000 

timestep        0.005 #Si el timestep es de 100.0 se rompe diciendo que el fene bond is too long
thermo          100

#dump 2 all atom 100 dump.polymer


run 20000
Copy<br>Esta es la forma en la que pude adaptar el código de magcolloids con bonds y angles. Hay cosas comentadas porque aún no sé cómo implementarlas bien. <br>En el video de ovito, se puede ver como las 3 partículas se juntan en un ángulo, lo que significa que el ángulo se implementó correctamente.<br>
Tenía planeado:<br>
Automatizar.<br>
Hacer una cadena más larga.<br>
Preguntarle cómo implementar bien el campo. ]]></description><link>Reporte Semanal\Semestre 2\Semana 2 (Semestre 2).html</link><guid isPermaLink="false">Reporte Semanal/Semestre 2/Semana 2 (Semestre 2).md</guid><pubDate>Mon, 19 Aug 2024 23:38:32 GMT</pubDate></item><item><title><![CDATA[Untitled]]></title><description><![CDATA[ 
 ]]></description><link>Reporte Semanal\Untitled.html</link><guid isPermaLink="false">Reporte Semanal/Untitled.md</guid><pubDate>Wed, 21 Aug 2024 15:34:07 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 ]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Mon, 19 Aug 2024 23:59:22 GMT</pubDate></item></channel></rss>